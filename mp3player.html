<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>mp3player API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mp3player</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import tkinter as tk
from tkinter import ttk as ttk
from PIL import ImageTk,Image
from mutagen.mp3 import MP3
from tkinter import filedialog
import os
import pygame
import time
import json
import random
from tkinter.font import Font



class Layout(tk.Tk):
    def __init__(self) -&gt; None:
        super().__init__()
        &#34;&#34;&#34;In this gigantic init function there&#39;s all the different widgets, like buttons, scales, scrollbars, frames, checkbuttons, string and intvars etc...
        &#34;&#34;&#34;
        # the frames
        
        self.title(&#34;Audify MP3 player&#34;)
        self.geometry(&#34;700x400&#34;)
        self.masterframe = tk.Frame(self)
        self.masterframe.pack()
        self.topframe = tk.Frame(self.masterframe,bg = &#34;white&#34;)
        self.topframe.grid(row = 0,column = 0)
        self.title_frame = tk.Frame(self.masterframe,bg = &#34;white&#34;)
        self.title_frame.grid(row = 1,column =0)
        self.songframe = tk.Frame(self.masterframe,bg = &#34;white&#34;)
        self.songframe.grid(row = 2,column = 0)
        self.bottomframe = tk.Frame(self.masterframe)
        self.bottomframe.grid(row = 3,column = 0)
        self.volumeframe = ttk.LabelFrame(self.masterframe,text = &#34;Volume&#34;)
        self.volumeframe.grid(row = 2,column = 1)
        self.songscaleframe = tk.Frame(self.masterframe)
        self.songscaleframe.grid(row =4,column = 0)

        #get the current path of the winamp folder, it will be important becuase this path is used to access the images, as well as the playlist.json file
        self.path = os.getcwd()
        
    
        #this is where the playlist will
        self.filename = os.path.join(f&#34;{self.path}&#34;, &#34;playlist.json&#34;)
        
        with open(self.filename,&#34;rt&#34;) as file:
            self.favourites = json.load(file)
    
        #the list of the songs in the music folder, that is brought in by the load_song module
        
        #stringvar
        self.scalevar = tk.IntVar()
        self.loopvar = tk.IntVar()
        self.shufflevar = tk.IntVar()
        
        

        #font for the music
        self.font = tk.font.Font(family=&#39;Helvetica&#39;,size=12,weight=&#39;bold&#39;,slant=&#39;italic&#39;,underline=0,overstrike=0)

        #add menus
        self.topmenu = tk.Menu(self.topframe)
        self.config(menu = self.topmenu)
        
        
        self.show_playlist = tk.Menu(self.topmenu)
        self.topmenu.add_cascade(label = &#34;Show Favourites&#34;,menu = self.show_playlist)
        self.show_playlist.add_command(label = &#34;Show favourites playlist&#34;,command = self.show_favourites)
        self.show_playlist.add_command(label = &#34;add songs for favourites playlist&#34;,command = self.add_favourites)
        
    
        self.refresh_menu = tk.Menu(self.topmenu)
        self.topmenu.add_cascade(label = &#34;Refresh&#34;,menu = self.refresh_menu)
        self.refresh_menu.add_command(label = &#34;Refresh the playlist, and load new songs in&#34;,command = self.refresh)
        

        self.delete_menu = tk.Menu(self.topmenu)
        self.topmenu.add_cascade(label = &#34;delete song from all songs&#34;,menu = self.delete_menu)
        self.delete_menu.add_command(label = &#34;delete selected song from the listbox&#34;,command = self.delete_song)
        

        #listbox in the song (middle) frame

        self.music_scrollbar = tk.Scrollbar(self.songframe,bg = &#34;grey&#34;,orient = &#34;vertical&#34;)
        self.music_scrollbar.grid(row = 0,column = 1,sticky = &#34;ns&#34;)

        self.songbox = tk.Listbox(self.songframe,bg = &#34;white&#34;,width = 55,selectmode = &#34;single&#34;,font = self.font)
        self.songbox.grid(row = 0,column = 0)
        self.music_scrollbar.config(command = self.songbox.yview)
        self.songbox.config(yscrollcommand=self.music_scrollbar.set)

        self.volume_slider = tk.Scale(self.volumeframe,from_ = 100, to= 0,orient = tk.VERTICAL,command = self.volume,length = 125)
        self.volume_slider.set(100)
        self.song_slider = tk.Scale(self.songscaleframe,from_ = 0, to= 100,orient = tk.HORIZONTAL,length = 500)
        self.song_slider.set(0)
        self.song_slider.pack(pady = 20)
        self.volume_slider.pack(pady = 22)

        # status bar, that gets the duration of the song
        self.status_bar = tk.Label(self.songscaleframe, text=&#34;no song playing&#34;, bd=1, relief=tk.GROOVE)
        self.status_bar.pack()
        
        

        #resizing the buttons that have been imported by the image folder
        #getting the raw image from the folder
        #first joining the images folder, than joining the names of the pngs
        self.images_folder_path = os.path.join(f&#34;{self.path}&#34;, &#34;images&#34;)
        
        
        raw_playbutton = Image.open(os.path.join(f&#34;{self.images_folder_path}&#34;, &#34;4.png&#34;))
        raw_pausebutton = Image.open(os.path.join(f&#34;{self.images_folder_path}&#34;, &#34;5.png&#34;))
        raw_unpausebutton = Image.open(os.path.join(f&#34;{self.images_folder_path}&#34;, &#34;1.png&#34;))
        raw_nextbutton = Image.open(os.path.join(f&#34;{self.images_folder_path}&#34;, &#34;2.png&#34;))
        raw_previousbutton = Image.open(os.path.join(f&#34;{self.images_folder_path}&#34;, &#34;3.png&#34;))
        raw_loopbutton = Image.open(os.path.join(f&#34;{self.images_folder_path}&#34;, &#34;7.png&#34;))
        raw_shufflebutton = Image.open(os.path.join(f&#34;{self.images_folder_path}&#34;, &#34;6.png&#34;))
        raw_disabled_back_button = Image.open(os.path.join(f&#34;{self.images_folder_path}&#34;, &#34;8.png&#34;))
        raw_normal_back_button = Image.open(os.path.join(f&#34;{self.images_folder_path}&#34;, &#34;9.png&#34;))

        #resizing the image with antialising

        resized_playbutton = raw_playbutton.resize((40,40),Image.ANTIALIAS)
        resized_pausebutton = raw_pausebutton.resize((40,40),Image.ANTIALIAS)
        resized_unpausebutton = raw_unpausebutton.resize((40,40),Image.ANTIALIAS)
        resized_nextbutton = raw_nextbutton.resize((40,40),Image.ANTIALIAS)
        resized_previousbutton = raw_previousbutton.resize((40,40),Image.ANTIALIAS)
        resized_loopbutton = raw_loopbutton.resize((50,50),Image.ANTIALIAS)
        resized_shufflebutton = raw_shufflebutton.resize((50,50),Image.ANTIALIAS)
        resized_disabled_back_button = raw_disabled_back_button.resize((50,50),Image.ANTIALIAS)
        resized_normal_back_button = raw_normal_back_button.resize((50,50),Image.ANTIALIAS)

        # getting the image that will be used

        self.playbutton_im = ImageTk.PhotoImage(resized_playbutton)
        self.pausebutton_im = ImageTk.PhotoImage(resized_pausebutton)
        self.unpausebutton_im = ImageTk.PhotoImage(resized_unpausebutton)
        self.nextbutton_im = ImageTk.PhotoImage(resized_nextbutton)
        self.previousbutton_im = ImageTk.PhotoImage(resized_previousbutton)
        self.loopbutton_im = ImageTk.PhotoImage(resized_loopbutton)
        self.shufflebutton_im = ImageTk.PhotoImage(resized_shufflebutton)
        self.disabled_back_button_im = ImageTk.PhotoImage(resized_disabled_back_button)
        self.normal_back_button_im = ImageTk.PhotoImage(resized_normal_back_button)

        #pygame event
        self.SONG_END = pygame.USEREVENT + 1
        pygame.mixer.music.set_endevent(self.SONG_END)
        

        #buttons on the third frame
        self.pause_button = tk.Button(self.bottomframe,image =self.pausebutton_im,borderwidth = 0,command = self.stop_button_pressed)
        self.pause_button.grid(row = 0,column = 2,padx = 5)
        self.unpause_button = tk.Button(self.bottomframe,image =self.unpausebutton_im,borderwidth = 0,command = self.unstop_button_pressed)
        self.unpause_button.grid(row = 0,column = 3,padx = 5)
        self.play_button = tk.Button(self.bottomframe,image =self.playbutton_im,borderwidth = 0,command =self.play_button_pressed)
        self.play_button.grid(row = 0,column = 1,padx = 5)
        self.next_button = tk.Button(self.bottomframe,image = self.nextbutton_im,borderwidth = 0,command =self.next_button_pressed)
        self.next_button.grid(row = 0,column = 4,padx = 5)
        self.previous_button = tk.Button(self.bottomframe,image = self.previousbutton_im,borderwidth = 0,command = self.previous_button_pressed)
        self.previous_button.grid(row = 0,column = 0,padx = 5)
        self.loop_button = tk.Checkbutton(self.bottomframe,image = self.loopbutton_im,variable = self.loopvar,onvalue = 1,offvalue = 0,borderwidth = 0,command = self.loop_button_pressed)
        self.loop_button.grid(row = 0,column = 5,padx = 5)
        self.shuffle_button = tk.Checkbutton(self.bottomframe,image = self.shufflebutton_im,variable = self.shufflevar,onvalue = 1,offvalue = 0,borderwidth = 0,command = self.shuffle_button_pressed)
        self.shuffle_button.grid(row = 0,column = 6,padx = 5)
        self.back_button = tk.Button(self.bottomframe,image = self.disabled_back_button_im,borderwidth = 0, state = tk.DISABLED,command = self.back_button_pressed)
        self.back_button.grid(row = 0,column = 7,padx = 5)
        self.current_label = tk.Label(self.title_frame,text = &#34;All Songs: &#34;)
        self.current_label.grid(row = 0,column = 0)

    def create_new_window(self,output:str) -&gt; None:
        &#34;&#34;&#34;
        This function is only for avoiding code repetition, it creates a new window with a problem message

        Args:
            output (str): the string that will be put out on the new window
        &#34;&#34;&#34;

        newWindow = tk.Toplevel(self)
        newWindow.title(&#34;problem happened&#34;)
        newWindow.geometry(&#34;400x200&#34;)
        new_frame = tk.Frame(newWindow)
        new_frame.pack()
            
        select_label = tk.Label(new_frame,text = output)
        select_label.grid(row =0,column=0)

    def show_favourites(self):
        &#34;&#34;&#34;
        this is the command that is executed when the show favourites playlist is clicked. If the playlist is empty, there is no need to show it, so only a message will pop up
        in a new window
        &#34;&#34;&#34;
        if len(self.favourites) == 0:
            
            self.create_new_window(&#34;Your favourite playlist is empty. Try putting in some new songs into it first&#34;)

        else:

            self.songbox.delete(0,tk.END)
            self.defeault_song_list = self.song_list
            for i in range(len(self.favourites)):
                self.songbox.insert(tk.END, self.favourites[i])
            
            self.current_label.config(text = &#34;Favourite playlist:&#34;)
            self.topmenu.entryconfig(3,label = &#34;Delete songs from Favourite playlits&#34;)

            
            self.back_button.config(state = tk.NORMAL,image = self.normal_back_button_im)

    def add_favourites(self):
        &#34;&#34;&#34;
        this commnand is called when the user wants to put in new songs into the playlist. first it generates a new window with the full songlist, the user can choose multiple songs from it,
        and then if you press the tick button the next function is called.
        &#34;&#34;&#34;
        self.newWindow = tk.Toplevel(self)
        self.newWindow.title(&#34;Create playlist&#34;)
        self.newWindow.geometry(&#34;700x400&#34;)
        self.new_frame = tk.Frame(self.newWindow)
        self.new_frame.pack()

        done_button = tk.Button(self.new_frame,text = &#34;insert selected into playlist&#34;,bg = &#34;white&#34;,command = self.done_button_pressed)
        done_button.grid(row = 3, column =0)

        self.select_label = tk.Label(self.new_frame,text = &#34;Select the songs you want to put into the favourites playlist&#34;)
        self.select_label.grid(row =0,column=0)

        music_scrollbar = tk.Scrollbar(self.new_frame,bg = &#34;grey&#34;,orient = &#34;vertical&#34;)
        music_scrollbar.grid(row = 2,column = 1,sticky = &#34;ns&#34;)

        self.new_songbox = tk.Listbox(self.new_frame,bg = &#34;white&#34;,width = 50,selectmode = &#34;multiple&#34;,font = self.font)
        self.new_songbox.grid(row = 2,column= 0)
        music_scrollbar.config(command = self.new_songbox.yview)
        self.new_songbox.config(yscrollcommand=music_scrollbar.set)
        
        #put in all the songs from the original into this for selection
        for i in range(len(self.song_list)):
            if self.song_list[i].endswith(&#34;.mp3&#34;):
                self.new_songbox.insert(tk.END, self.song_list[i])

    def done_button_pressed(self) -&gt; None:
        &#34;&#34;&#34;
        when the user is done with choosing new songs, than they can press the button with a tick on it, and then the new window will be destroyed. if the user clicks on the show playlist again,
        it will be shoing the new and refreshed favourites playlist with the chosen songs in it as well as previous ones
        &#34;&#34;&#34;
        selected_songs = [self.new_songbox.get(i) for i in self.new_songbox.curselection()]
        
        for i in range(len(selected_songs)):

            self.favourites.append(selected_songs[i])
        
        with open(self.filename,&#34;r&#34;) as file:
            
            in_songs = json.load(file)
            joined_list = in_songs + selected_songs
        
        with open(self.filename,&#34;w&#34;) as file:
            json.dump(joined_list, file)
                    
                
        self.newWindow.destroy()

    def create_lisbox(self) -&gt; None:
        &#34;&#34;&#34;
        This function creates the listbox that will display the songs, and also gets called when we want to display the playlist
        &#34;&#34;&#34;
       
        self.directory = filedialog.askdirectory()


        os.chdir(self.directory)
        directory = os.listdir()
        self.song_list = []

        for i in range(len(directory)):
            if directory[i].endswith(&#34;.mp3&#34;):
               self.song_list.append(directory[i])
        
        for i in range(len(self.song_list)):
            self.songbox.insert(tk.END, self.song_list[i])
            
    def back_button_pressed(self):
        &#34;&#34;&#34;
        this is only pressable if the playlist is shown. if the songbox is set to the playlist the backj button&#39;s icon will turn into normal, and it can be clicked. upon clicking it
        the songbox will update, and it will generate back into the original default songs
        &#34;&#34;&#34;
        self.songbox.delete(0, tk.END)
        self.song_list = self.defeault_song_list
        for i in range(len(self.song_list)):
            self.songbox.insert(tk.END, self.song_list[i])
        self.back_button.config(state = tk.DISABLED,image = self.disabled_back_button_im)
        self.current_label.config(text = &#34;All songs:&#34;)
        self.topmenu.entryconfig(3,label = &#34;Delete songs from all songs&#34;)
        self.song_list = self.defeault_song_list

    def loop_button_pressed(self) -&gt; None:
        &#34;&#34;&#34;
        In this function if the loop button is pressed, than the song will be looped once
        &#34;&#34;&#34;
        
        current_song = self.songbox.get(tk.ACTIVE)
        pygame.mixer.music.queue(current_song)
        
    def shuffle_button_pressed(self) -&gt; None:
        &#34;&#34;&#34;
        In this function If the shufle button is turned on, then the next song in the queue will be a random one, aka shuffled one
        &#34;&#34;&#34;
        value = self.shufflevar.get()
        current_song = self.songbox.get(tk.ACTIVE)
        if value == 1:
            random_song = random.randint(0,len(self.song_list)-1)
            pygame.mixer.music.queue(self.song_list[random_song])
        else:
            pygame.mixer.music.queue(current_song)
        
    
    def delete_song_from_playlist(self,current_song: str) -&gt; None:
        &#34;&#34;&#34;
        This is in a function only, to avoid code repetition, and gets called 2 times in the delete song function

        Args:
            current_song (str): This is the current song that is selected, and will be removed
        &#34;&#34;&#34;

        for i in range(len(self.favourites)):
            if self.favourites[i] == current_song:
                index = i

        self.songbox.delete(index,last =None)
        self.favourites.pop(index)
        
        with open(self.filename,&#34;r&#34;) as file:
            
            in_songs = json.load(file)
            in_songs.remove(current_song)
                    
        with open(self.filename,&#34;w&#34;) as file:
            json.dump(in_songs, file)
        
        if len(self.favourites) == 0:
            self.back_button_pressed()

    def delete_song(self) -&gt; None:
        &#34;&#34;&#34;
        This is a function that first checks if the song list that is shown is the all songs playlist, or the favoruites playlist, and than if the full playlist is shown
        it will delete the song that is currently selected, and if its in the playlist, than it will get deleted from there as well.
        if the playlist is shown, it will get deleted only from there
        &#34;&#34;&#34;
        current_song = self.songbox.get(tk.ACTIVE)
        if self.song_list == self.defeault_song_list:

            for i in range(len(self.song_list)):
                if self.song_list[i] == current_song:
                    index = i
            self.songbox.delete(index,last =None)
            self.song_list.pop(index)

            if current_song in self.favourites:
                self.delete_song_from_playlist(current_song)
        
        if self.song_list == self.favourites:

            self.delete_song_from_playlist(current_song)

            if len(self.favourites) == 0:
                for i in range(len(self.defeault_song_list)):
                    self.songbox.insert(tk.END, self.defeault_song_list[i])
        
        
        


    def get_playtime(self) -&gt; None:
        
        &#34;&#34;&#34;
        This function determines the current position of the song, for the song slider, also this function determines the length of the currently playing song.
        This function is constently getting called, if a new song is in the queue, so we can get the length, and make the slider go to the current position.
        Also it converts these times
        &#34;&#34;&#34;

        current_time = pygame.mixer.music.get_pos() / 1000
        converted_current_time = time.strftime(&#39;%M:%S&#39;, time.gmtime(current_time))

        self.status_bar.after(1000, self.get_playtime)
        song = self.songbox.get(tk.ACTIVE)
        song = os.path.join(f&#34;{self.directory}&#34;, f&#34;{song}&#34;)
        song_mut = MP3(song)
        global song_length
        song_length = song_mut.info.length
        self.song_slider.set(current_time)
        converted_song_length = time.strftime(&#39;%M:%S&#39;, time.gmtime(song_length))
        self.status_bar.config(text = f&#34;duration: {converted_current_time} out of {converted_song_length}&#34;)

    def check_event(self) -&gt; None:
        &#34;&#34;&#34;
        At first glance this function doesn&#39;t do that much but this holds the whole playlist together. This loops the songs, and keeps the queue playing.
        &#34;&#34;&#34;
        
        for event in pygame.event.get():
            if event.type == self.SONG_END:
                
                self.next_button_pressed()
                
                
                
        self.after(1000,self.check_event)
        
    def refresh(self) -&gt; None:
        &#34;&#34;&#34;
        This function is the command of the refresh label, so when it gets called it will refresh the whole listbox, and loads in new songs that have just been loaded.
        This function serves as a comfort, more than a functionality, because you don&#39;t have to exit the mp3 player to load in the songs
        &#34;&#34;&#34;
        self.songbox.delete(0, tk.END)
        self.song_list = []
        directory = os.listdir()
        
        for i in range(len(directory)):
            if directory[i].endswith(&#34;.mp3&#34;):
               self.song_list.append(directory[i])
        
        for i in range(len(self.song_list)):
            self.songbox.insert(tk.END, self.song_list[i])
        


    def play_button_pressed(self):
        &#34;&#34;&#34;
        if the user clicks on a song in the songbox and clickes this, it will start the song and play it.
        &#34;&#34;&#34;
        
        pygame.init()
        pygame.mixer.init()
        song = self.songbox.get(tk.ACTIVE)
        song = os.path.join(f&#34;{self.directory}&#34;, f&#34;{song}&#34;)
        pygame.mixer.music.load(song)
        pygame.mixer.music.play()
        self.get_playtime()
        slide_position = int(song_length)
        self.song_slider.config(to = slide_position)
        self.song_slider.set(0)
        self.check_event()
        
        
    def unstop_button_pressed(self):
        &#34;&#34;&#34;
        it will stop the song
        &#34;&#34;&#34;
        pygame.mixer.music.unpause()


    def next_button_pressed(self):
        &#34;&#34;&#34;
        this is callled when the user clickes the next button. if the loop checkbox is cliced, the user cannot click the next button, and the current song is set to looping.
        if the shuffle checkbox is pressed, than the next song will be a random one.
        &#34;&#34;&#34;
        shuffle_value = self.shufflevar.get()
        loop_value = self.loopvar.get()
        if shuffle_value == 1:
            random_song = random.randint(0,len(self.song_list)-1)
            if loop_value ==1:
                self.loop_button_pressed()
            else:
                
                pygame.mixer.music.load(self.song_list[random_song])
                pygame.mixer.music.play()
                
                self.songbox.selection_clear(0, tk.END)
                self.songbox.selection_set(random_song, last=None)
                self.songbox.activate(random_song)
                self.get_playtime()
                slide_position = int(song_length)
                self.song_slider.config(to = slide_position)
                self.song_slider.set(0)
                
                self.check_event()
            
        if shuffle_value == 0:
            if loop_value ==1:
                self.loop_button_pressed()
            else:
                

                next_one = self.songbox.curselection()
                next_one = next_one[0]+1
                song = self.songbox.get(next_one)
                song = f&#39;{self.directory}/{song}&#39;
                
                pygame.mixer.music.load(song)
                pygame.mixer.music.play(loops=0)
                

                self.songbox.selection_clear(0, tk.END)
                self.songbox.activate(next_one)
                self.songbox.selection_set(next_one, last=None)
                self.get_playtime()
                slide_position = int(song_length)
                self.song_slider.config(to = slide_position)
                self.song_slider.set(0)
                
                self.check_event()
    
    def stop_button_pressed(self):
        &#34;&#34;&#34;
        stops the music(pauses)
        &#34;&#34;&#34;
        pygame.mixer.music.pause()

    def previous_button_pressed(self):
        &#34;&#34;&#34;
        plays the previous song
        &#34;&#34;&#34;
        previous_one = self.songbox.curselection()
        previous_one = previous_one[0]-1
        song = self.songbox.get(previous_one)

        
        pygame.mixer.music.load(song)
        pygame.mixer.music.play(loops=0)

        self.songbox.selection_clear(0, tk.END)
        self.songbox.activate(previous_one)
        self.songbox.selection_set(previous_one, last=None)
        self.get_playtime()
        slide_position = int(song_length)
        self.song_slider.config(to = slide_position)
        self.song_slider.set(0)
        self.check_event()
    
    #set the volume
    def volume(self,vol):
        &#34;&#34;&#34;
        this is the function to get the volume to to the stuff it need to do
        Args:
            vol (int): this is only needed becuase this is the value that the function uses forthe value of the current volume
        &#34;&#34;&#34;
        pygame.init()
        pygame.mixer.init()
        
        self.scalevar = int(vol) / 100
        pygame.mixer.music.set_volume(self.scalevar)
        

layout = Layout()
layout.create_lisbox()
layout.mainloop()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mp3player.Layout"><code class="flex name class">
<span>class <span class="ident">Layout</span></span>
</code></dt>
<dd>
<div class="desc"><p>Toplevel widget of Tk which represents mostly the main window
of an application. It has an associated Tcl interpreter.</p>
<p>Return a new Toplevel widget on screen SCREENNAME. A new Tcl interpreter will
be created. BASENAME will be used for the identification of the profile file (see
readprofile).
It is constructed from sys.argv[0] without extensions if None is given. CLASSNAME
is the name of the widget class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Layout(tk.Tk):
    def __init__(self) -&gt; None:
        super().__init__()
        &#34;&#34;&#34;In this gigantic init function there&#39;s all the different widgets, like buttons, scales, scrollbars, frames, checkbuttons, string and intvars etc...
        &#34;&#34;&#34;
        # the frames
        
        self.title(&#34;Audify MP3 player&#34;)
        self.geometry(&#34;700x400&#34;)
        self.masterframe = tk.Frame(self)
        self.masterframe.pack()
        self.topframe = tk.Frame(self.masterframe,bg = &#34;white&#34;)
        self.topframe.grid(row = 0,column = 0)
        self.title_frame = tk.Frame(self.masterframe,bg = &#34;white&#34;)
        self.title_frame.grid(row = 1,column =0)
        self.songframe = tk.Frame(self.masterframe,bg = &#34;white&#34;)
        self.songframe.grid(row = 2,column = 0)
        self.bottomframe = tk.Frame(self.masterframe)
        self.bottomframe.grid(row = 3,column = 0)
        self.volumeframe = ttk.LabelFrame(self.masterframe,text = &#34;Volume&#34;)
        self.volumeframe.grid(row = 2,column = 1)
        self.songscaleframe = tk.Frame(self.masterframe)
        self.songscaleframe.grid(row =4,column = 0)

        #get the current path of the winamp folder, it will be important becuase this path is used to access the images, as well as the playlist.json file
        self.path = os.getcwd()
        
    
        #this is where the playlist will
        self.filename = os.path.join(f&#34;{self.path}&#34;, &#34;playlist.json&#34;)
        
        with open(self.filename,&#34;rt&#34;) as file:
            self.favourites = json.load(file)
    
        #the list of the songs in the music folder, that is brought in by the load_song module
        
        #stringvar
        self.scalevar = tk.IntVar()
        self.loopvar = tk.IntVar()
        self.shufflevar = tk.IntVar()
        
        

        #font for the music
        self.font = tk.font.Font(family=&#39;Helvetica&#39;,size=12,weight=&#39;bold&#39;,slant=&#39;italic&#39;,underline=0,overstrike=0)

        #add menus
        self.topmenu = tk.Menu(self.topframe)
        self.config(menu = self.topmenu)
        
        
        self.show_playlist = tk.Menu(self.topmenu)
        self.topmenu.add_cascade(label = &#34;Show Favourites&#34;,menu = self.show_playlist)
        self.show_playlist.add_command(label = &#34;Show favourites playlist&#34;,command = self.show_favourites)
        self.show_playlist.add_command(label = &#34;add songs for favourites playlist&#34;,command = self.add_favourites)
        
    
        self.refresh_menu = tk.Menu(self.topmenu)
        self.topmenu.add_cascade(label = &#34;Refresh&#34;,menu = self.refresh_menu)
        self.refresh_menu.add_command(label = &#34;Refresh the playlist, and load new songs in&#34;,command = self.refresh)
        

        self.delete_menu = tk.Menu(self.topmenu)
        self.topmenu.add_cascade(label = &#34;delete song from all songs&#34;,menu = self.delete_menu)
        self.delete_menu.add_command(label = &#34;delete selected song from the listbox&#34;,command = self.delete_song)
        

        #listbox in the song (middle) frame

        self.music_scrollbar = tk.Scrollbar(self.songframe,bg = &#34;grey&#34;,orient = &#34;vertical&#34;)
        self.music_scrollbar.grid(row = 0,column = 1,sticky = &#34;ns&#34;)

        self.songbox = tk.Listbox(self.songframe,bg = &#34;white&#34;,width = 55,selectmode = &#34;single&#34;,font = self.font)
        self.songbox.grid(row = 0,column = 0)
        self.music_scrollbar.config(command = self.songbox.yview)
        self.songbox.config(yscrollcommand=self.music_scrollbar.set)

        self.volume_slider = tk.Scale(self.volumeframe,from_ = 100, to= 0,orient = tk.VERTICAL,command = self.volume,length = 125)
        self.volume_slider.set(100)
        self.song_slider = tk.Scale(self.songscaleframe,from_ = 0, to= 100,orient = tk.HORIZONTAL,length = 500)
        self.song_slider.set(0)
        self.song_slider.pack(pady = 20)
        self.volume_slider.pack(pady = 22)

        # status bar, that gets the duration of the song
        self.status_bar = tk.Label(self.songscaleframe, text=&#34;no song playing&#34;, bd=1, relief=tk.GROOVE)
        self.status_bar.pack()
        
        

        #resizing the buttons that have been imported by the image folder
        #getting the raw image from the folder
        #first joining the images folder, than joining the names of the pngs
        self.images_folder_path = os.path.join(f&#34;{self.path}&#34;, &#34;images&#34;)
        
        
        raw_playbutton = Image.open(os.path.join(f&#34;{self.images_folder_path}&#34;, &#34;4.png&#34;))
        raw_pausebutton = Image.open(os.path.join(f&#34;{self.images_folder_path}&#34;, &#34;5.png&#34;))
        raw_unpausebutton = Image.open(os.path.join(f&#34;{self.images_folder_path}&#34;, &#34;1.png&#34;))
        raw_nextbutton = Image.open(os.path.join(f&#34;{self.images_folder_path}&#34;, &#34;2.png&#34;))
        raw_previousbutton = Image.open(os.path.join(f&#34;{self.images_folder_path}&#34;, &#34;3.png&#34;))
        raw_loopbutton = Image.open(os.path.join(f&#34;{self.images_folder_path}&#34;, &#34;7.png&#34;))
        raw_shufflebutton = Image.open(os.path.join(f&#34;{self.images_folder_path}&#34;, &#34;6.png&#34;))
        raw_disabled_back_button = Image.open(os.path.join(f&#34;{self.images_folder_path}&#34;, &#34;8.png&#34;))
        raw_normal_back_button = Image.open(os.path.join(f&#34;{self.images_folder_path}&#34;, &#34;9.png&#34;))

        #resizing the image with antialising

        resized_playbutton = raw_playbutton.resize((40,40),Image.ANTIALIAS)
        resized_pausebutton = raw_pausebutton.resize((40,40),Image.ANTIALIAS)
        resized_unpausebutton = raw_unpausebutton.resize((40,40),Image.ANTIALIAS)
        resized_nextbutton = raw_nextbutton.resize((40,40),Image.ANTIALIAS)
        resized_previousbutton = raw_previousbutton.resize((40,40),Image.ANTIALIAS)
        resized_loopbutton = raw_loopbutton.resize((50,50),Image.ANTIALIAS)
        resized_shufflebutton = raw_shufflebutton.resize((50,50),Image.ANTIALIAS)
        resized_disabled_back_button = raw_disabled_back_button.resize((50,50),Image.ANTIALIAS)
        resized_normal_back_button = raw_normal_back_button.resize((50,50),Image.ANTIALIAS)

        # getting the image that will be used

        self.playbutton_im = ImageTk.PhotoImage(resized_playbutton)
        self.pausebutton_im = ImageTk.PhotoImage(resized_pausebutton)
        self.unpausebutton_im = ImageTk.PhotoImage(resized_unpausebutton)
        self.nextbutton_im = ImageTk.PhotoImage(resized_nextbutton)
        self.previousbutton_im = ImageTk.PhotoImage(resized_previousbutton)
        self.loopbutton_im = ImageTk.PhotoImage(resized_loopbutton)
        self.shufflebutton_im = ImageTk.PhotoImage(resized_shufflebutton)
        self.disabled_back_button_im = ImageTk.PhotoImage(resized_disabled_back_button)
        self.normal_back_button_im = ImageTk.PhotoImage(resized_normal_back_button)

        #pygame event
        self.SONG_END = pygame.USEREVENT + 1
        pygame.mixer.music.set_endevent(self.SONG_END)
        

        #buttons on the third frame
        self.pause_button = tk.Button(self.bottomframe,image =self.pausebutton_im,borderwidth = 0,command = self.stop_button_pressed)
        self.pause_button.grid(row = 0,column = 2,padx = 5)
        self.unpause_button = tk.Button(self.bottomframe,image =self.unpausebutton_im,borderwidth = 0,command = self.unstop_button_pressed)
        self.unpause_button.grid(row = 0,column = 3,padx = 5)
        self.play_button = tk.Button(self.bottomframe,image =self.playbutton_im,borderwidth = 0,command =self.play_button_pressed)
        self.play_button.grid(row = 0,column = 1,padx = 5)
        self.next_button = tk.Button(self.bottomframe,image = self.nextbutton_im,borderwidth = 0,command =self.next_button_pressed)
        self.next_button.grid(row = 0,column = 4,padx = 5)
        self.previous_button = tk.Button(self.bottomframe,image = self.previousbutton_im,borderwidth = 0,command = self.previous_button_pressed)
        self.previous_button.grid(row = 0,column = 0,padx = 5)
        self.loop_button = tk.Checkbutton(self.bottomframe,image = self.loopbutton_im,variable = self.loopvar,onvalue = 1,offvalue = 0,borderwidth = 0,command = self.loop_button_pressed)
        self.loop_button.grid(row = 0,column = 5,padx = 5)
        self.shuffle_button = tk.Checkbutton(self.bottomframe,image = self.shufflebutton_im,variable = self.shufflevar,onvalue = 1,offvalue = 0,borderwidth = 0,command = self.shuffle_button_pressed)
        self.shuffle_button.grid(row = 0,column = 6,padx = 5)
        self.back_button = tk.Button(self.bottomframe,image = self.disabled_back_button_im,borderwidth = 0, state = tk.DISABLED,command = self.back_button_pressed)
        self.back_button.grid(row = 0,column = 7,padx = 5)
        self.current_label = tk.Label(self.title_frame,text = &#34;All Songs: &#34;)
        self.current_label.grid(row = 0,column = 0)

    def create_new_window(self,output:str) -&gt; None:
        &#34;&#34;&#34;
        This function is only for avoiding code repetition, it creates a new window with a problem message

        Args:
            output (str): the string that will be put out on the new window
        &#34;&#34;&#34;

        newWindow = tk.Toplevel(self)
        newWindow.title(&#34;problem happened&#34;)
        newWindow.geometry(&#34;400x200&#34;)
        new_frame = tk.Frame(newWindow)
        new_frame.pack()
            
        select_label = tk.Label(new_frame,text = output)
        select_label.grid(row =0,column=0)

    def show_favourites(self):
        &#34;&#34;&#34;
        this is the command that is executed when the show favourites playlist is clicked. If the playlist is empty, there is no need to show it, so only a message will pop up
        in a new window
        &#34;&#34;&#34;
        if len(self.favourites) == 0:
            
            self.create_new_window(&#34;Your favourite playlist is empty. Try putting in some new songs into it first&#34;)

        else:

            self.songbox.delete(0,tk.END)
            self.defeault_song_list = self.song_list
            for i in range(len(self.favourites)):
                self.songbox.insert(tk.END, self.favourites[i])
            
            self.current_label.config(text = &#34;Favourite playlist:&#34;)
            self.topmenu.entryconfig(3,label = &#34;Delete songs from Favourite playlits&#34;)

            
            self.back_button.config(state = tk.NORMAL,image = self.normal_back_button_im)

    def add_favourites(self):
        &#34;&#34;&#34;
        this commnand is called when the user wants to put in new songs into the playlist. first it generates a new window with the full songlist, the user can choose multiple songs from it,
        and then if you press the tick button the next function is called.
        &#34;&#34;&#34;
        self.newWindow = tk.Toplevel(self)
        self.newWindow.title(&#34;Create playlist&#34;)
        self.newWindow.geometry(&#34;700x400&#34;)
        self.new_frame = tk.Frame(self.newWindow)
        self.new_frame.pack()

        done_button = tk.Button(self.new_frame,text = &#34;insert selected into playlist&#34;,bg = &#34;white&#34;,command = self.done_button_pressed)
        done_button.grid(row = 3, column =0)

        self.select_label = tk.Label(self.new_frame,text = &#34;Select the songs you want to put into the favourites playlist&#34;)
        self.select_label.grid(row =0,column=0)

        music_scrollbar = tk.Scrollbar(self.new_frame,bg = &#34;grey&#34;,orient = &#34;vertical&#34;)
        music_scrollbar.grid(row = 2,column = 1,sticky = &#34;ns&#34;)

        self.new_songbox = tk.Listbox(self.new_frame,bg = &#34;white&#34;,width = 50,selectmode = &#34;multiple&#34;,font = self.font)
        self.new_songbox.grid(row = 2,column= 0)
        music_scrollbar.config(command = self.new_songbox.yview)
        self.new_songbox.config(yscrollcommand=music_scrollbar.set)
        
        #put in all the songs from the original into this for selection
        for i in range(len(self.song_list)):
            if self.song_list[i].endswith(&#34;.mp3&#34;):
                self.new_songbox.insert(tk.END, self.song_list[i])

    def done_button_pressed(self) -&gt; None:
        &#34;&#34;&#34;
        when the user is done with choosing new songs, than they can press the button with a tick on it, and then the new window will be destroyed. if the user clicks on the show playlist again,
        it will be shoing the new and refreshed favourites playlist with the chosen songs in it as well as previous ones
        &#34;&#34;&#34;
        selected_songs = [self.new_songbox.get(i) for i in self.new_songbox.curselection()]
        
        for i in range(len(selected_songs)):

            self.favourites.append(selected_songs[i])
        
        with open(self.filename,&#34;r&#34;) as file:
            
            in_songs = json.load(file)
            joined_list = in_songs + selected_songs
        
        with open(self.filename,&#34;w&#34;) as file:
            json.dump(joined_list, file)
                    
                
        self.newWindow.destroy()

    def create_lisbox(self) -&gt; None:
        &#34;&#34;&#34;
        This function creates the listbox that will display the songs, and also gets called when we want to display the playlist
        &#34;&#34;&#34;
       
        self.directory = filedialog.askdirectory()


        os.chdir(self.directory)
        directory = os.listdir()
        self.song_list = []

        for i in range(len(directory)):
            if directory[i].endswith(&#34;.mp3&#34;):
               self.song_list.append(directory[i])
        
        for i in range(len(self.song_list)):
            self.songbox.insert(tk.END, self.song_list[i])
            
    def back_button_pressed(self):
        &#34;&#34;&#34;
        this is only pressable if the playlist is shown. if the songbox is set to the playlist the backj button&#39;s icon will turn into normal, and it can be clicked. upon clicking it
        the songbox will update, and it will generate back into the original default songs
        &#34;&#34;&#34;
        self.songbox.delete(0, tk.END)
        self.song_list = self.defeault_song_list
        for i in range(len(self.song_list)):
            self.songbox.insert(tk.END, self.song_list[i])
        self.back_button.config(state = tk.DISABLED,image = self.disabled_back_button_im)
        self.current_label.config(text = &#34;All songs:&#34;)
        self.topmenu.entryconfig(3,label = &#34;Delete songs from all songs&#34;)
        self.song_list = self.defeault_song_list

    def loop_button_pressed(self) -&gt; None:
        &#34;&#34;&#34;
        In this function if the loop button is pressed, than the song will be looped once
        &#34;&#34;&#34;
        
        current_song = self.songbox.get(tk.ACTIVE)
        pygame.mixer.music.queue(current_song)
        
    def shuffle_button_pressed(self) -&gt; None:
        &#34;&#34;&#34;
        In this function If the shufle button is turned on, then the next song in the queue will be a random one, aka shuffled one
        &#34;&#34;&#34;
        value = self.shufflevar.get()
        current_song = self.songbox.get(tk.ACTIVE)
        if value == 1:
            random_song = random.randint(0,len(self.song_list)-1)
            pygame.mixer.music.queue(self.song_list[random_song])
        else:
            pygame.mixer.music.queue(current_song)
        
    
    def delete_song_from_playlist(self,current_song: str) -&gt; None:
        &#34;&#34;&#34;
        This is in a function only, to avoid code repetition, and gets called 2 times in the delete song function

        Args:
            current_song (str): This is the current song that is selected, and will be removed
        &#34;&#34;&#34;

        for i in range(len(self.favourites)):
            if self.favourites[i] == current_song:
                index = i

        self.songbox.delete(index,last =None)
        self.favourites.pop(index)
        
        with open(self.filename,&#34;r&#34;) as file:
            
            in_songs = json.load(file)
            in_songs.remove(current_song)
                    
        with open(self.filename,&#34;w&#34;) as file:
            json.dump(in_songs, file)
        
        if len(self.favourites) == 0:
            self.back_button_pressed()

    def delete_song(self) -&gt; None:
        &#34;&#34;&#34;
        This is a function that first checks if the song list that is shown is the all songs playlist, or the favoruites playlist, and than if the full playlist is shown
        it will delete the song that is currently selected, and if its in the playlist, than it will get deleted from there as well.
        if the playlist is shown, it will get deleted only from there
        &#34;&#34;&#34;
        current_song = self.songbox.get(tk.ACTIVE)
        if self.song_list == self.defeault_song_list:

            for i in range(len(self.song_list)):
                if self.song_list[i] == current_song:
                    index = i
            self.songbox.delete(index,last =None)
            self.song_list.pop(index)

            if current_song in self.favourites:
                self.delete_song_from_playlist(current_song)
        
        if self.song_list == self.favourites:

            self.delete_song_from_playlist(current_song)

            if len(self.favourites) == 0:
                for i in range(len(self.defeault_song_list)):
                    self.songbox.insert(tk.END, self.defeault_song_list[i])
        
        
        


    def get_playtime(self) -&gt; None:
        
        &#34;&#34;&#34;
        This function determines the current position of the song, for the song slider, also this function determines the length of the currently playing song.
        This function is constently getting called, if a new song is in the queue, so we can get the length, and make the slider go to the current position.
        Also it converts these times
        &#34;&#34;&#34;

        current_time = pygame.mixer.music.get_pos() / 1000
        converted_current_time = time.strftime(&#39;%M:%S&#39;, time.gmtime(current_time))

        self.status_bar.after(1000, self.get_playtime)
        song = self.songbox.get(tk.ACTIVE)
        song = os.path.join(f&#34;{self.directory}&#34;, f&#34;{song}&#34;)
        song_mut = MP3(song)
        global song_length
        song_length = song_mut.info.length
        self.song_slider.set(current_time)
        converted_song_length = time.strftime(&#39;%M:%S&#39;, time.gmtime(song_length))
        self.status_bar.config(text = f&#34;duration: {converted_current_time} out of {converted_song_length}&#34;)

    def check_event(self) -&gt; None:
        &#34;&#34;&#34;
        At first glance this function doesn&#39;t do that much but this holds the whole playlist together. This loops the songs, and keeps the queue playing.
        &#34;&#34;&#34;
        
        for event in pygame.event.get():
            if event.type == self.SONG_END:
                
                self.next_button_pressed()
                
                
                
        self.after(1000,self.check_event)
        
    def refresh(self) -&gt; None:
        &#34;&#34;&#34;
        This function is the command of the refresh label, so when it gets called it will refresh the whole listbox, and loads in new songs that have just been loaded.
        This function serves as a comfort, more than a functionality, because you don&#39;t have to exit the mp3 player to load in the songs
        &#34;&#34;&#34;
        self.songbox.delete(0, tk.END)
        self.song_list = []
        directory = os.listdir()
        
        for i in range(len(directory)):
            if directory[i].endswith(&#34;.mp3&#34;):
               self.song_list.append(directory[i])
        
        for i in range(len(self.song_list)):
            self.songbox.insert(tk.END, self.song_list[i])
        


    def play_button_pressed(self):
        &#34;&#34;&#34;
        if the user clicks on a song in the songbox and clickes this, it will start the song and play it.
        &#34;&#34;&#34;
        
        pygame.init()
        pygame.mixer.init()
        song = self.songbox.get(tk.ACTIVE)
        song = os.path.join(f&#34;{self.directory}&#34;, f&#34;{song}&#34;)
        pygame.mixer.music.load(song)
        pygame.mixer.music.play()
        self.get_playtime()
        slide_position = int(song_length)
        self.song_slider.config(to = slide_position)
        self.song_slider.set(0)
        self.check_event()
        
        
    def unstop_button_pressed(self):
        &#34;&#34;&#34;
        it will stop the song
        &#34;&#34;&#34;
        pygame.mixer.music.unpause()


    def next_button_pressed(self):
        &#34;&#34;&#34;
        this is callled when the user clickes the next button. if the loop checkbox is cliced, the user cannot click the next button, and the current song is set to looping.
        if the shuffle checkbox is pressed, than the next song will be a random one.
        &#34;&#34;&#34;
        shuffle_value = self.shufflevar.get()
        loop_value = self.loopvar.get()
        if shuffle_value == 1:
            random_song = random.randint(0,len(self.song_list)-1)
            if loop_value ==1:
                self.loop_button_pressed()
            else:
                
                pygame.mixer.music.load(self.song_list[random_song])
                pygame.mixer.music.play()
                
                self.songbox.selection_clear(0, tk.END)
                self.songbox.selection_set(random_song, last=None)
                self.songbox.activate(random_song)
                self.get_playtime()
                slide_position = int(song_length)
                self.song_slider.config(to = slide_position)
                self.song_slider.set(0)
                
                self.check_event()
            
        if shuffle_value == 0:
            if loop_value ==1:
                self.loop_button_pressed()
            else:
                

                next_one = self.songbox.curselection()
                next_one = next_one[0]+1
                song = self.songbox.get(next_one)
                song = f&#39;{self.directory}/{song}&#39;
                
                pygame.mixer.music.load(song)
                pygame.mixer.music.play(loops=0)
                

                self.songbox.selection_clear(0, tk.END)
                self.songbox.activate(next_one)
                self.songbox.selection_set(next_one, last=None)
                self.get_playtime()
                slide_position = int(song_length)
                self.song_slider.config(to = slide_position)
                self.song_slider.set(0)
                
                self.check_event()
    
    def stop_button_pressed(self):
        &#34;&#34;&#34;
        stops the music(pauses)
        &#34;&#34;&#34;
        pygame.mixer.music.pause()

    def previous_button_pressed(self):
        &#34;&#34;&#34;
        plays the previous song
        &#34;&#34;&#34;
        previous_one = self.songbox.curselection()
        previous_one = previous_one[0]-1
        song = self.songbox.get(previous_one)

        
        pygame.mixer.music.load(song)
        pygame.mixer.music.play(loops=0)

        self.songbox.selection_clear(0, tk.END)
        self.songbox.activate(previous_one)
        self.songbox.selection_set(previous_one, last=None)
        self.get_playtime()
        slide_position = int(song_length)
        self.song_slider.config(to = slide_position)
        self.song_slider.set(0)
        self.check_event()
    
    #set the volume
    def volume(self,vol):
        &#34;&#34;&#34;
        this is the function to get the volume to to the stuff it need to do
        Args:
            vol (int): this is only needed becuase this is the value that the function uses forthe value of the current volume
        &#34;&#34;&#34;
        pygame.init()
        pygame.mixer.init()
        
        self.scalevar = int(vol) / 100
        pygame.mixer.music.set_volume(self.scalevar)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Tk</li>
<li>tkinter.Misc</li>
<li>tkinter.Wm</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mp3player.Layout.add_favourites"><code class="name flex">
<span>def <span class="ident">add_favourites</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>this commnand is called when the user wants to put in new songs into the playlist. first it generates a new window with the full songlist, the user can choose multiple songs from it,
and then if you press the tick button the next function is called.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_favourites(self):
    &#34;&#34;&#34;
    this commnand is called when the user wants to put in new songs into the playlist. first it generates a new window with the full songlist, the user can choose multiple songs from it,
    and then if you press the tick button the next function is called.
    &#34;&#34;&#34;
    self.newWindow = tk.Toplevel(self)
    self.newWindow.title(&#34;Create playlist&#34;)
    self.newWindow.geometry(&#34;700x400&#34;)
    self.new_frame = tk.Frame(self.newWindow)
    self.new_frame.pack()

    done_button = tk.Button(self.new_frame,text = &#34;insert selected into playlist&#34;,bg = &#34;white&#34;,command = self.done_button_pressed)
    done_button.grid(row = 3, column =0)

    self.select_label = tk.Label(self.new_frame,text = &#34;Select the songs you want to put into the favourites playlist&#34;)
    self.select_label.grid(row =0,column=0)

    music_scrollbar = tk.Scrollbar(self.new_frame,bg = &#34;grey&#34;,orient = &#34;vertical&#34;)
    music_scrollbar.grid(row = 2,column = 1,sticky = &#34;ns&#34;)

    self.new_songbox = tk.Listbox(self.new_frame,bg = &#34;white&#34;,width = 50,selectmode = &#34;multiple&#34;,font = self.font)
    self.new_songbox.grid(row = 2,column= 0)
    music_scrollbar.config(command = self.new_songbox.yview)
    self.new_songbox.config(yscrollcommand=music_scrollbar.set)
    
    #put in all the songs from the original into this for selection
    for i in range(len(self.song_list)):
        if self.song_list[i].endswith(&#34;.mp3&#34;):
            self.new_songbox.insert(tk.END, self.song_list[i])</code></pre>
</details>
</dd>
<dt id="mp3player.Layout.back_button_pressed"><code class="name flex">
<span>def <span class="ident">back_button_pressed</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>this is only pressable if the playlist is shown. if the songbox is set to the playlist the backj button's icon will turn into normal, and it can be clicked. upon clicking it
the songbox will update, and it will generate back into the original default songs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def back_button_pressed(self):
    &#34;&#34;&#34;
    this is only pressable if the playlist is shown. if the songbox is set to the playlist the backj button&#39;s icon will turn into normal, and it can be clicked. upon clicking it
    the songbox will update, and it will generate back into the original default songs
    &#34;&#34;&#34;
    self.songbox.delete(0, tk.END)
    self.song_list = self.defeault_song_list
    for i in range(len(self.song_list)):
        self.songbox.insert(tk.END, self.song_list[i])
    self.back_button.config(state = tk.DISABLED,image = self.disabled_back_button_im)
    self.current_label.config(text = &#34;All songs:&#34;)
    self.topmenu.entryconfig(3,label = &#34;Delete songs from all songs&#34;)
    self.song_list = self.defeault_song_list</code></pre>
</details>
</dd>
<dt id="mp3player.Layout.check_event"><code class="name flex">
<span>def <span class="ident">check_event</span></span>(<span>self) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>At first glance this function doesn't do that much but this holds the whole playlist together. This loops the songs, and keeps the queue playing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_event(self) -&gt; None:
    &#34;&#34;&#34;
    At first glance this function doesn&#39;t do that much but this holds the whole playlist together. This loops the songs, and keeps the queue playing.
    &#34;&#34;&#34;
    
    for event in pygame.event.get():
        if event.type == self.SONG_END:
            
            self.next_button_pressed()
            
            
            
    self.after(1000,self.check_event)</code></pre>
</details>
</dd>
<dt id="mp3player.Layout.create_lisbox"><code class="name flex">
<span>def <span class="ident">create_lisbox</span></span>(<span>self) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>This function creates the listbox that will display the songs, and also gets called when we want to display the playlist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_lisbox(self) -&gt; None:
    &#34;&#34;&#34;
    This function creates the listbox that will display the songs, and also gets called when we want to display the playlist
    &#34;&#34;&#34;
   
    self.directory = filedialog.askdirectory()


    os.chdir(self.directory)
    directory = os.listdir()
    self.song_list = []

    for i in range(len(directory)):
        if directory[i].endswith(&#34;.mp3&#34;):
           self.song_list.append(directory[i])
    
    for i in range(len(self.song_list)):
        self.songbox.insert(tk.END, self.song_list[i])</code></pre>
</details>
</dd>
<dt id="mp3player.Layout.create_new_window"><code class="name flex">
<span>def <span class="ident">create_new_window</span></span>(<span>self, output:str) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>This function is only for avoiding code repetition, it creates a new window with a problem message</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>output</code></strong> :&ensp;<code>str</code></dt>
<dd>the string that will be put out on the new window</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_new_window(self,output:str) -&gt; None:
    &#34;&#34;&#34;
    This function is only for avoiding code repetition, it creates a new window with a problem message

    Args:
        output (str): the string that will be put out on the new window
    &#34;&#34;&#34;

    newWindow = tk.Toplevel(self)
    newWindow.title(&#34;problem happened&#34;)
    newWindow.geometry(&#34;400x200&#34;)
    new_frame = tk.Frame(newWindow)
    new_frame.pack()
        
    select_label = tk.Label(new_frame,text = output)
    select_label.grid(row =0,column=0)</code></pre>
</details>
</dd>
<dt id="mp3player.Layout.delete_song"><code class="name flex">
<span>def <span class="ident">delete_song</span></span>(<span>self) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>This is a function that first checks if the song list that is shown is the all songs playlist, or the favoruites playlist, and than if the full playlist is shown
it will delete the song that is currently selected, and if its in the playlist, than it will get deleted from there as well.
if the playlist is shown, it will get deleted only from there</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_song(self) -&gt; None:
    &#34;&#34;&#34;
    This is a function that first checks if the song list that is shown is the all songs playlist, or the favoruites playlist, and than if the full playlist is shown
    it will delete the song that is currently selected, and if its in the playlist, than it will get deleted from there as well.
    if the playlist is shown, it will get deleted only from there
    &#34;&#34;&#34;
    current_song = self.songbox.get(tk.ACTIVE)
    if self.song_list == self.defeault_song_list:

        for i in range(len(self.song_list)):
            if self.song_list[i] == current_song:
                index = i
        self.songbox.delete(index,last =None)
        self.song_list.pop(index)

        if current_song in self.favourites:
            self.delete_song_from_playlist(current_song)
    
    if self.song_list == self.favourites:

        self.delete_song_from_playlist(current_song)

        if len(self.favourites) == 0:
            for i in range(len(self.defeault_song_list)):
                self.songbox.insert(tk.END, self.defeault_song_list[i])</code></pre>
</details>
</dd>
<dt id="mp3player.Layout.delete_song_from_playlist"><code class="name flex">
<span>def <span class="ident">delete_song_from_playlist</span></span>(<span>self, current_song:str) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>This is in a function only, to avoid code repetition, and gets called 2 times in the delete song function</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>current_song</code></strong> :&ensp;<code>str</code></dt>
<dd>This is the current song that is selected, and will be removed</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_song_from_playlist(self,current_song: str) -&gt; None:
    &#34;&#34;&#34;
    This is in a function only, to avoid code repetition, and gets called 2 times in the delete song function

    Args:
        current_song (str): This is the current song that is selected, and will be removed
    &#34;&#34;&#34;

    for i in range(len(self.favourites)):
        if self.favourites[i] == current_song:
            index = i

    self.songbox.delete(index,last =None)
    self.favourites.pop(index)
    
    with open(self.filename,&#34;r&#34;) as file:
        
        in_songs = json.load(file)
        in_songs.remove(current_song)
                
    with open(self.filename,&#34;w&#34;) as file:
        json.dump(in_songs, file)
    
    if len(self.favourites) == 0:
        self.back_button_pressed()</code></pre>
</details>
</dd>
<dt id="mp3player.Layout.done_button_pressed"><code class="name flex">
<span>def <span class="ident">done_button_pressed</span></span>(<span>self) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>when the user is done with choosing new songs, than they can press the button with a tick on it, and then the new window will be destroyed. if the user clicks on the show playlist again,
it will be shoing the new and refreshed favourites playlist with the chosen songs in it as well as previous ones</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def done_button_pressed(self) -&gt; None:
    &#34;&#34;&#34;
    when the user is done with choosing new songs, than they can press the button with a tick on it, and then the new window will be destroyed. if the user clicks on the show playlist again,
    it will be shoing the new and refreshed favourites playlist with the chosen songs in it as well as previous ones
    &#34;&#34;&#34;
    selected_songs = [self.new_songbox.get(i) for i in self.new_songbox.curselection()]
    
    for i in range(len(selected_songs)):

        self.favourites.append(selected_songs[i])
    
    with open(self.filename,&#34;r&#34;) as file:
        
        in_songs = json.load(file)
        joined_list = in_songs + selected_songs
    
    with open(self.filename,&#34;w&#34;) as file:
        json.dump(joined_list, file)
                
            
    self.newWindow.destroy()</code></pre>
</details>
</dd>
<dt id="mp3player.Layout.get_playtime"><code class="name flex">
<span>def <span class="ident">get_playtime</span></span>(<span>self) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>This function determines the current position of the song, for the song slider, also this function determines the length of the currently playing song.
This function is constently getting called, if a new song is in the queue, so we can get the length, and make the slider go to the current position.
Also it converts these times</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_playtime(self) -&gt; None:
    
    &#34;&#34;&#34;
    This function determines the current position of the song, for the song slider, also this function determines the length of the currently playing song.
    This function is constently getting called, if a new song is in the queue, so we can get the length, and make the slider go to the current position.
    Also it converts these times
    &#34;&#34;&#34;

    current_time = pygame.mixer.music.get_pos() / 1000
    converted_current_time = time.strftime(&#39;%M:%S&#39;, time.gmtime(current_time))

    self.status_bar.after(1000, self.get_playtime)
    song = self.songbox.get(tk.ACTIVE)
    song = os.path.join(f&#34;{self.directory}&#34;, f&#34;{song}&#34;)
    song_mut = MP3(song)
    global song_length
    song_length = song_mut.info.length
    self.song_slider.set(current_time)
    converted_song_length = time.strftime(&#39;%M:%S&#39;, time.gmtime(song_length))
    self.status_bar.config(text = f&#34;duration: {converted_current_time} out of {converted_song_length}&#34;)</code></pre>
</details>
</dd>
<dt id="mp3player.Layout.loop_button_pressed"><code class="name flex">
<span>def <span class="ident">loop_button_pressed</span></span>(<span>self) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>In this function if the loop button is pressed, than the song will be looped once</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loop_button_pressed(self) -&gt; None:
    &#34;&#34;&#34;
    In this function if the loop button is pressed, than the song will be looped once
    &#34;&#34;&#34;
    
    current_song = self.songbox.get(tk.ACTIVE)
    pygame.mixer.music.queue(current_song)</code></pre>
</details>
</dd>
<dt id="mp3player.Layout.next_button_pressed"><code class="name flex">
<span>def <span class="ident">next_button_pressed</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>this is callled when the user clickes the next button. if the loop checkbox is cliced, the user cannot click the next button, and the current song is set to looping.
if the shuffle checkbox is pressed, than the next song will be a random one.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def next_button_pressed(self):
    &#34;&#34;&#34;
    this is callled when the user clickes the next button. if the loop checkbox is cliced, the user cannot click the next button, and the current song is set to looping.
    if the shuffle checkbox is pressed, than the next song will be a random one.
    &#34;&#34;&#34;
    shuffle_value = self.shufflevar.get()
    loop_value = self.loopvar.get()
    if shuffle_value == 1:
        random_song = random.randint(0,len(self.song_list)-1)
        if loop_value ==1:
            self.loop_button_pressed()
        else:
            
            pygame.mixer.music.load(self.song_list[random_song])
            pygame.mixer.music.play()
            
            self.songbox.selection_clear(0, tk.END)
            self.songbox.selection_set(random_song, last=None)
            self.songbox.activate(random_song)
            self.get_playtime()
            slide_position = int(song_length)
            self.song_slider.config(to = slide_position)
            self.song_slider.set(0)
            
            self.check_event()
        
    if shuffle_value == 0:
        if loop_value ==1:
            self.loop_button_pressed()
        else:
            

            next_one = self.songbox.curselection()
            next_one = next_one[0]+1
            song = self.songbox.get(next_one)
            song = f&#39;{self.directory}/{song}&#39;
            
            pygame.mixer.music.load(song)
            pygame.mixer.music.play(loops=0)
            

            self.songbox.selection_clear(0, tk.END)
            self.songbox.activate(next_one)
            self.songbox.selection_set(next_one, last=None)
            self.get_playtime()
            slide_position = int(song_length)
            self.song_slider.config(to = slide_position)
            self.song_slider.set(0)
            
            self.check_event()</code></pre>
</details>
</dd>
<dt id="mp3player.Layout.play_button_pressed"><code class="name flex">
<span>def <span class="ident">play_button_pressed</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>if the user clicks on a song in the songbox and clickes this, it will start the song and play it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def play_button_pressed(self):
    &#34;&#34;&#34;
    if the user clicks on a song in the songbox and clickes this, it will start the song and play it.
    &#34;&#34;&#34;
    
    pygame.init()
    pygame.mixer.init()
    song = self.songbox.get(tk.ACTIVE)
    song = os.path.join(f&#34;{self.directory}&#34;, f&#34;{song}&#34;)
    pygame.mixer.music.load(song)
    pygame.mixer.music.play()
    self.get_playtime()
    slide_position = int(song_length)
    self.song_slider.config(to = slide_position)
    self.song_slider.set(0)
    self.check_event()</code></pre>
</details>
</dd>
<dt id="mp3player.Layout.previous_button_pressed"><code class="name flex">
<span>def <span class="ident">previous_button_pressed</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>plays the previous song</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def previous_button_pressed(self):
    &#34;&#34;&#34;
    plays the previous song
    &#34;&#34;&#34;
    previous_one = self.songbox.curselection()
    previous_one = previous_one[0]-1
    song = self.songbox.get(previous_one)

    
    pygame.mixer.music.load(song)
    pygame.mixer.music.play(loops=0)

    self.songbox.selection_clear(0, tk.END)
    self.songbox.activate(previous_one)
    self.songbox.selection_set(previous_one, last=None)
    self.get_playtime()
    slide_position = int(song_length)
    self.song_slider.config(to = slide_position)
    self.song_slider.set(0)
    self.check_event()</code></pre>
</details>
</dd>
<dt id="mp3player.Layout.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>This function is the command of the refresh label, so when it gets called it will refresh the whole listbox, and loads in new songs that have just been loaded.
This function serves as a comfort, more than a functionality, because you don't have to exit the mp3 player to load in the songs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(self) -&gt; None:
    &#34;&#34;&#34;
    This function is the command of the refresh label, so when it gets called it will refresh the whole listbox, and loads in new songs that have just been loaded.
    This function serves as a comfort, more than a functionality, because you don&#39;t have to exit the mp3 player to load in the songs
    &#34;&#34;&#34;
    self.songbox.delete(0, tk.END)
    self.song_list = []
    directory = os.listdir()
    
    for i in range(len(directory)):
        if directory[i].endswith(&#34;.mp3&#34;):
           self.song_list.append(directory[i])
    
    for i in range(len(self.song_list)):
        self.songbox.insert(tk.END, self.song_list[i])</code></pre>
</details>
</dd>
<dt id="mp3player.Layout.show_favourites"><code class="name flex">
<span>def <span class="ident">show_favourites</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>this is the command that is executed when the show favourites playlist is clicked. If the playlist is empty, there is no need to show it, so only a message will pop up
in a new window</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_favourites(self):
    &#34;&#34;&#34;
    this is the command that is executed when the show favourites playlist is clicked. If the playlist is empty, there is no need to show it, so only a message will pop up
    in a new window
    &#34;&#34;&#34;
    if len(self.favourites) == 0:
        
        self.create_new_window(&#34;Your favourite playlist is empty. Try putting in some new songs into it first&#34;)

    else:

        self.songbox.delete(0,tk.END)
        self.defeault_song_list = self.song_list
        for i in range(len(self.favourites)):
            self.songbox.insert(tk.END, self.favourites[i])
        
        self.current_label.config(text = &#34;Favourite playlist:&#34;)
        self.topmenu.entryconfig(3,label = &#34;Delete songs from Favourite playlits&#34;)

        
        self.back_button.config(state = tk.NORMAL,image = self.normal_back_button_im)</code></pre>
</details>
</dd>
<dt id="mp3player.Layout.shuffle_button_pressed"><code class="name flex">
<span>def <span class="ident">shuffle_button_pressed</span></span>(<span>self) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>In this function If the shufle button is turned on, then the next song in the queue will be a random one, aka shuffled one</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shuffle_button_pressed(self) -&gt; None:
    &#34;&#34;&#34;
    In this function If the shufle button is turned on, then the next song in the queue will be a random one, aka shuffled one
    &#34;&#34;&#34;
    value = self.shufflevar.get()
    current_song = self.songbox.get(tk.ACTIVE)
    if value == 1:
        random_song = random.randint(0,len(self.song_list)-1)
        pygame.mixer.music.queue(self.song_list[random_song])
    else:
        pygame.mixer.music.queue(current_song)</code></pre>
</details>
</dd>
<dt id="mp3player.Layout.stop_button_pressed"><code class="name flex">
<span>def <span class="ident">stop_button_pressed</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>stops the music(pauses)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_button_pressed(self):
    &#34;&#34;&#34;
    stops the music(pauses)
    &#34;&#34;&#34;
    pygame.mixer.music.pause()</code></pre>
</details>
</dd>
<dt id="mp3player.Layout.unstop_button_pressed"><code class="name flex">
<span>def <span class="ident">unstop_button_pressed</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>it will stop the song</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unstop_button_pressed(self):
    &#34;&#34;&#34;
    it will stop the song
    &#34;&#34;&#34;
    pygame.mixer.music.unpause()</code></pre>
</details>
</dd>
<dt id="mp3player.Layout.volume"><code class="name flex">
<span>def <span class="ident">volume</span></span>(<span>self, vol)</span>
</code></dt>
<dd>
<div class="desc"><p>this is the function to get the volume to to the stuff it need to do</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vol</code></strong> :&ensp;<code>int</code></dt>
<dd>this is only needed becuase this is the value that the function uses forthe value of the current volume</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def volume(self,vol):
    &#34;&#34;&#34;
    this is the function to get the volume to to the stuff it need to do
    Args:
        vol (int): this is only needed becuase this is the value that the function uses forthe value of the current volume
    &#34;&#34;&#34;
    pygame.init()
    pygame.mixer.init()
    
    self.scalevar = int(vol) / 100
    pygame.mixer.music.set_volume(self.scalevar)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mp3player.Layout" href="#mp3player.Layout">Layout</a></code></h4>
<ul class="">
<li><code><a title="mp3player.Layout.add_favourites" href="#mp3player.Layout.add_favourites">add_favourites</a></code></li>
<li><code><a title="mp3player.Layout.back_button_pressed" href="#mp3player.Layout.back_button_pressed">back_button_pressed</a></code></li>
<li><code><a title="mp3player.Layout.check_event" href="#mp3player.Layout.check_event">check_event</a></code></li>
<li><code><a title="mp3player.Layout.create_lisbox" href="#mp3player.Layout.create_lisbox">create_lisbox</a></code></li>
<li><code><a title="mp3player.Layout.create_new_window" href="#mp3player.Layout.create_new_window">create_new_window</a></code></li>
<li><code><a title="mp3player.Layout.delete_song" href="#mp3player.Layout.delete_song">delete_song</a></code></li>
<li><code><a title="mp3player.Layout.delete_song_from_playlist" href="#mp3player.Layout.delete_song_from_playlist">delete_song_from_playlist</a></code></li>
<li><code><a title="mp3player.Layout.done_button_pressed" href="#mp3player.Layout.done_button_pressed">done_button_pressed</a></code></li>
<li><code><a title="mp3player.Layout.get_playtime" href="#mp3player.Layout.get_playtime">get_playtime</a></code></li>
<li><code><a title="mp3player.Layout.loop_button_pressed" href="#mp3player.Layout.loop_button_pressed">loop_button_pressed</a></code></li>
<li><code><a title="mp3player.Layout.next_button_pressed" href="#mp3player.Layout.next_button_pressed">next_button_pressed</a></code></li>
<li><code><a title="mp3player.Layout.play_button_pressed" href="#mp3player.Layout.play_button_pressed">play_button_pressed</a></code></li>
<li><code><a title="mp3player.Layout.previous_button_pressed" href="#mp3player.Layout.previous_button_pressed">previous_button_pressed</a></code></li>
<li><code><a title="mp3player.Layout.refresh" href="#mp3player.Layout.refresh">refresh</a></code></li>
<li><code><a title="mp3player.Layout.show_favourites" href="#mp3player.Layout.show_favourites">show_favourites</a></code></li>
<li><code><a title="mp3player.Layout.shuffle_button_pressed" href="#mp3player.Layout.shuffle_button_pressed">shuffle_button_pressed</a></code></li>
<li><code><a title="mp3player.Layout.stop_button_pressed" href="#mp3player.Layout.stop_button_pressed">stop_button_pressed</a></code></li>
<li><code><a title="mp3player.Layout.unstop_button_pressed" href="#mp3player.Layout.unstop_button_pressed">unstop_button_pressed</a></code></li>
<li><code><a title="mp3player.Layout.volume" href="#mp3player.Layout.volume">volume</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>